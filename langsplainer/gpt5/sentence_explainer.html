<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sentence Explainer with GPT-5</title>
    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Optional: Include a CSS library or custom styles here -->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #fafafa;
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            box-sizing: border-box;
            resize: vertical;
        }
        input[type="text"], input[type="password"] {
            padding: 8px;
            margin-top: 10px;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            margin-top: 10px;
            cursor: pointer;
        }
        .explanation {
            background-color: #f0f0f0;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            position: relative; /* For positioning the copy button */
        }
        .explanation h3 {
            margin-top: 0;
        }
        .error {
            color: red;
            margin-top: 10px;
        }
        .toggle-button {
            margin-left: 10px;
            padding: 5px 10px;
            font-size: 0.9em;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .stats {
            font-size: 0.8em;
            margin-top: 10px;
            color: #666;
        }
        .results-container {
            display: flex;
            gap: 20px; /* Spacing between columns */
        }
        .model-column {
            flex: 1; /* Each column takes equal width */
        }
        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            font-size: 0.8em;
            cursor: pointer;
        }
        /* HTML output styling */
        .html-output h3 { margin: 0.6em 0 0.3em; }
        .html-output h4 { margin: 0.8em 0 0.4em; }
        .html-output ul { margin: 0.25em 0 0.75em 1.25em; }
        .html-output li { margin: 0.2em 0; }
        .html-output rt { font-size: 0.6em; color: #666; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script id="defaultSystemPrompt" type="text/plain">
You are an expert bilingual teaching assistant specializing in Chinese. Your primary goal is to create "Chinese-first, maximum-value" sentence breakdowns for language learners, formatted in clean HTML.

Your task is to take a single Chinese sentence and break it down following the precise format and principles below. Pack the most helpful information into the smallest space, encouraging the learner to stay in Chinese as long as possible.

### Guiding Principles
1.  Chinese First: Always present Chinese content before its English equivalent.
2.  Chunking: Analyze meaningful phrases (e.g., æˆè¯­, æ­é…) first, then break down their component words.
3.  **Contextual Grammar**: If a clause contains a noteworthy grammatical pattern, structure, or function word, provide a concise explanation *after* the vocabulary list for that clause.
4.  Efficiency: Provide only essential metadata: pinyin, part-of-speech, a concise Chinese gloss, and a concise English gloss.
5.  Formatting: Pinyin and all English text **must be italicized** using `<i>` tags (not `<em>`).

### Strict HTML Formatting Rules

1.  Clause Headings:
    *   Begin each clause with an `<h3>` tag.
    *   The format must be: `<h3><segmented Chinese clause></h3>`.
    *   Example: `<h3>ä¸ºäº† é¡¾å…¨é¢å­ï¼Œ</h3>`

2.  Vocabulary/Phrase List:
    *   Use a `<ul>` for the list of vocabulary and phrases.
    *   Each item must be in a `<li>` tag.
    *   The format MUST be: `<b>Word/Phrase</b> <i>pinyin</i> ã€POSã€‘ Chinese gloss/synonym â€” <i>English gloss</i>`
    *   Word/Phrase: must be wrapped in `<b>` tags.
    *   Pinyin & English gloss: must be wrapped in `<i>` tags. For pinyin, insert a centered dot before neutral tones (e.g., wÃ¨iÂ·le, miÃ nÂ·zi).
    *   ã€POSã€‘: Use single characters (å, åŠ¨, å½¢, å‰¯, ä»‹, è¿, é‡) or descriptive tags (æ­é…, ç»“æ„, æˆè¯­) as appropriate.

3.  **Grammar Notes (Conditional)**:
    *   **Only if** there is a relevant grammar point in the clause, add a `<div>` with the class `grammar-notes` immediately after the `<ul>` for vocabulary.
    *   Start this section with `<h4>ğŸ’¡è¯­æ³•ç‚¹</h4>`.
    *   Use a `<ul>` to list the grammar points.
    *   The format for each point MUST be: `<li><b>Pattern/Word</b>: Chinese explanation â€” <i>English explanation</i></li>`

### Gold-Standard HTML Example (Follow this PRECISELY)

**Input Sentence:** ä¸ºäº†é¡¾å…¨é¢å­ï¼Œä»–è£…å‡ºä¸€å‰¯éšéšä¾¿ä¾¿çš„æ ·å­ã€‚

**Required HTML Output (Output only the HTML fragment; do not include Markdown fences, headings, or commentary):**

<h3>ä¸ºäº† é¡¾å…¨é¢å­ï¼Œ</h3>
<ul>
  <li><b>ä¸ºäº†</b> <i>wÃ¨iÂ·le</i>ã€ä»‹ã€‘ä¸ºäº†â€¦çš„ç›®çš„ â€” <i>in order to; for the sake of</i></li>
  <li><b>é¡¾å…¨é¢å­</b> <i>gÃ¹quÃ¡n miÃ nÂ·zi</i>ã€æ­é…ã€‘ä¿å…¨é¢å­ â€” <i>to save face</i>
    <ul>
      <li><b>é¡¾å…¨</b> <i>gÃ¹quÃ¡n</i>ã€åŠ¨ã€‘ä¿å…¨ã€ç…§é¡¾ â€” <i>to preserve</i></li>
      <li><b>é¢å­</b> <i>miÃ nÂ·zi</i>ã€åã€‘ä½“é¢ã€è„¸é¢ â€” <i>face; reputation</i></li>
    </ul>
  </li>
</ul>
<h3>ä»– è£…å‡º ä¸€å‰¯ éšéšä¾¿ä¾¿ çš„ æ ·å­ã€‚</h3>
<ul>
  <li><b>è£…å‡º</b> <i>zhuÄngchÅ«</i>ã€åŠ¨ã€‘å‡è£…è¡¨ç° â€” <i>to feign; put on</i></li>
  <li><b>ä¸€å‰¯</b> <i>yÄ« fÃ¹</i>ã€é‡ã€‘ï¼ˆè¡¨ç¥æ€çš„é‡è¯ï¼‰ â€” <i>classifier for looks</i></li>
  <li><b>éšéšä¾¿ä¾¿</b> <i>suÃ­suÃ­-biÃ nbian</i>ã€å½¢ã€‘ä¸æ‹˜å°èŠ‚ã€å¾ˆéšæ„ â€” <i>casual; nonchalant</i></li>
  <li><b>æ ·å­</b> <i>yÃ ngÂ·zi</i>ã€åã€‘å¤–è¡¨ã€ç¥æ€ â€” <i>appearance; manner</i></li>
</ul>
<div class="grammar-notes">
  <h4>ğŸ’¡è¯­æ³•ç‚¹</h4>
  <ul>
    <li><b>â€œä¸€å‰¯...çš„æ ·å­â€</b>: æè¿°ç¥æ€æˆ–å¤–è¡¨çš„ç»“æ„ï¼Œâ€œå‰¯â€ä¸ºé‡è¯ï¼Œâ€œçš„â€ä½œè¿æ¥ã€‚ â€” <i>Describes a look or manner; "å‰¯" is the classifier, "çš„" links to "æ ·å­".</i></li>
    <li><b>éšéšä¾¿ä¾¿</b>: AABB å è¯ï¼Œå½¢è±¡æè¿°çŠ¶æ€æˆ–åŠ¨ä½œã€‚ â€” <i>A vivid AABB reduplication for states or actions.</i></li>
  </ul>
</div>
    </script>

    <script type="text/babel" data-type="module" data-presets="env,react,typescript">
        const { useState, useEffect, StrictMode } = React;

        // Default to GPT-5 family; override via UI or URL param `?models=gpt-5,gpt-5-mini`.
        const defaultModels = [
            "gpt-5",
            "gpt-5-mini",
            "gpt-5-nano",
            "gpt-5-chat-latest"
        ];

        // Strip common code fences like ```html ... ```
        const stripCodeFences = (s) => {
            if (!s) return '';
            let out = s.trim();
            out = out.replace(/^```(?:html)?\s*/i, '');
            out = out.replace(/\s*```$/i, '');
            return out.trim();
        };

        // Very light sanitizer to prevent script injection from model output
        const sanitizeHTML = (html) => {
            const doc = new DOMParser().parseFromString(html || '', 'text/html');
            doc.querySelectorAll('script, style, iframe, object, embed, link').forEach(el => el.remove());
            doc.querySelectorAll('*').forEach(el => {
                [...el.attributes].forEach(attr => {
                    const name = attr.name.toLowerCase();
                    const val = (attr.value || '').trim().toLowerCase();
                    if (name.startsWith('on')) el.removeAttribute(attr.name);
                    if ((name === 'href' || name === 'src') && val.startsWith('javascript:')) el.removeAttribute(attr.name);
                });
            });
            return doc.body.innerHTML;
        };

        const promptEl = document.getElementById('defaultSystemPrompt');
        const defaultSystemPrompt = (promptEl ? promptEl.textContent : '').trim();

        const SentenceExplainer = () => {
            // State variables
            const [sentence, setSentence] = useState('å›½å¤®ä¼å¦‚æ­¤çƒ­åˆ‡æ‹¥æŠ±å¤§æ¨¡å‹æˆ–ä¸ä¸€é“æ–°æ”¿æœ‰å…³ã€‚');
            const [apiKey, setApiKey] = useState('');
            const [results, setResults] = useState({}); // Store results for all models
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            const [showApiKey, setShowApiKey] = useState(false);
            const [isReady, setIsReady] = useState(false);
            const [systemPromptText, setSystemPromptText] = useState(defaultSystemPrompt);
            const [showSystemPrompt, setShowSystemPrompt] = useState(false);
            const [models, setModels] = useState(defaultModels);
            const [modelsText, setModelsText] = useState(defaultModels.join(', '));
            // Model discovery state
            const [availableModels, setAvailableModels] = useState([]);
            const [modelsLoading, setModelsLoading] = useState(false);
            const [modelsError, setModelsError] = useState(null);
            const [modelFilter, setModelFilter] = useState('');
            const [maxOutputTokens, setMaxOutputTokens] = useState(8192);

            // Load API key and sentence, then set isReady
            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const sentenceFromUrl = urlParams.get('sentence');
                const apiKeyFromUrl = urlParams.get('apiKey');
                const modelsFromUrl = urlParams.get('models');

                // Prioritize URL parameters over localStorage
                if (sentenceFromUrl) {
                    setSentence(decodeURIComponent(sentenceFromUrl));
                }

                const handleApiKey = (key) => {
                    if (key) {
                        setApiKey(key);
                        localStorage.setItem('openai_api_key', key);
                    }
                    setIsReady(true); // Everything is ready now
                };

                const parseModels = (s) => (s || '')
                    .split(',')
                    .map(x => x.trim())
                    .filter(Boolean);

                if (modelsFromUrl) {
                    const parsed = parseModels(decodeURIComponent(modelsFromUrl));
                    if (parsed.length) {
                        setModels(parsed);
                        const csv = parsed.join(', ');
                        setModelsText(csv);
                        localStorage.setItem('openai_models', csv);
                    }
                } else {
                    const storedModels = localStorage.getItem('openai_models');
                    if (storedModels) {
                        const parsed = parseModels(storedModels);
                        if (parsed.length) {
                            setModels(parsed);
                            setModelsText(storedModels);
                        }
                    }
                }

                if (apiKeyFromUrl) {
                    handleApiKey(decodeURIComponent(apiKeyFromUrl));
                } else {
                    const storedApiKey = localStorage.getItem('openai_api_key');
                    handleApiKey(storedApiKey);
                }
            }, []);

            // Fetch models when API key becomes available
            useEffect(() => {
                const fetchModels = async () => {
                    if (!apiKey) return;
                    setModelsLoading(true);
                    setModelsError(null);
                    try {
                        const resp = await fetch('https://api.openai.com/v1/models', {
                            method: 'GET',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`
                            }
                        });
                        if (!resp.ok) {
                            const text = await resp.text();
                            throw new Error(text || 'Failed to fetch models');
                        }
                        const data = await resp.json();
                        const ids = Array.isArray(data.data) ? data.data
                            .map((m) => m && (m.id || m.name) )
                            .filter(Boolean) : [];
                        // Prefer gpt-5 models early in the list
                        ids.sort((a, b) => {
                            const ag = a.includes('gpt-5') ? 0 : 1;
                            const bg = b.includes('gpt-5') ? 0 : 1;
                            if (ag !== bg) return ag - bg;
                            return a.localeCompare(b);
                        });
                        setAvailableModels(ids);

                        // If no stored/URL models, default-select gpt-5 family from fetched list
                        const stored = (localStorage.getItem('openai_models') || '').split(',').map(s => s.trim()).filter(Boolean);
                        const urlModels = new URLSearchParams(window.location.search).get('models');
                        const hasOverride = (stored && stored.length) || (urlModels && urlModels.trim().length);
                        if (!hasOverride) {
                            const gpt5 = ids.filter(id => id.includes('gpt-5'));
                            if (gpt5.length) {
                                setModels(gpt5);
                                const csv = gpt5.join(', ');
                                setModelsText(csv);
                                localStorage.setItem('openai_models', csv);
                            }
                        }
                    } catch (err) {
                        console.error('Model fetch error:', err);
                        setModelsError(err.message || String(err));
                    } finally {
                        setModelsLoading(false);
                    }
                };
                fetchModels();
            }, [apiKey]);

            // Trigger handleSubmit when isReady changes and sentence is available
            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const sentenceFromUrl = urlParams.get('sentence');
                if (isReady && sentenceFromUrl) {
                    handleSubmit(null, decodeURIComponent(sentenceFromUrl));
                }
            }, [isReady]);

            // Function to handle API key changes
            const handleApiKeyChange = (e) => {
                const value = e.target.value;
                setApiKey(value);
                localStorage.setItem('openai_api_key', value);
            };

            // Function to toggle API key visibility
            const toggleApiKeyVisibility = () => {
                setShowApiKey(!showApiKey);
            };

            // Handle models input changes (CSV manual entry)
            const handleModelsChange = (e) => {
                const value = e.target.value;
                setModelsText(value);
                const parsed = value.split(',').map(x => x.trim()).filter(Boolean);
                if (parsed.length) setModels(parsed);
                localStorage.setItem('openai_models', value);
            };

            // Handle multiselect change
            const handleModelSelect = (e) => {
                const opts = Array.from(e.target.selectedOptions).map(o => o.value);
                setModels(opts);
                const csv = opts.join(', ');
                setModelsText(csv);
                localStorage.setItem('openai_models', csv);
            };

            const selectFiltered = () => {
                const filtered = availableModels.filter(m => m.toLowerCase().includes(modelFilter.toLowerCase()));
                setModels(filtered);
                const csv = filtered.join(', ');
                setModelsText(csv);
                localStorage.setItem('openai_models', csv);
            };

            const clearSelection = () => {
                setModels([]);
                setModelsText('');
                localStorage.setItem('openai_models', '');
            };

            // Function to copy text to clipboard
            const copyToClipboard = (text) => {
                navigator.clipboard.writeText(text).then(() => {
                    // Optional: Show a success message or change the button text briefly
                    console.log('Text copied to clipboard');
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                });
            };

            // Function to handle form submission or direct call from URL param
            const handleSubmit = async (e, sentenceFromUrl = null) => {
                if (e) e.preventDefault();
                const currentSentence = sentenceFromUrl || sentence;
                setError(null);
                setResults({}); // Clear previous results
                setLoading(true);

                if (!apiKey) {
                    setError('Please provide your OpenAI API key.');
                    setLoading(false);
                    return;
                }

                if (!currentSentence.trim()) {
                    setError('Please enter a sentence to process.');
                    setLoading(false);
                    return;
                }

                if (!models || models.length === 0) {
                    setError('Please specify at least one model.');
                    setLoading(false);
                    return;
                }

                const tasks = models.map(async (model) => {
                    try {
                        const result = await queryOpenAI(model, currentSentence);
                        // Update results for the specific model as it completes
                        setResults((prevResults) => ({
                            ...prevResults,
                            [model]: result,
                        }));
                    } catch (err) {
                        console.error(`Error with model ${model}:`, err);
                        // Update results with an error for the specific model
                        setResults((prevResults) => ({
                            ...prevResults,
                            [model]: {
                                model: model,
                                explanation: null,
                                stats: `Error: ${err.message || 'An unexpected error occurred.'}`,
                            },
                        }));
                    }
                });

                // Wait for all models to finish before clearing loading state
                await Promise.allSettled(tasks);
                setLoading(false);
            };

            // Function to query a single OpenAI model
            const queryOpenAI = async (model, currentSentence) => {
                const startTime = performance.now();
                let endTime;
                let ttfb;

                // Prepare the system prompt from state
                const systemPrompt = systemPromptText;

                // Make the API call
                // Build request body, only include reasoning knob for non-chat models
                const requestBody = {
                    model,
                    // Provide system prompt as `instructions` per Responses API
                    instructions: systemPrompt,
                    // Simplest input shape per migration guide
                    input: currentSentence,
                    // Allow caller to control the output budget
                    max_output_tokens: Number(maxOutputTokens) || 2048
                };
                if (!/chat/i.test(model)) {
                    requestBody.reasoning = { effort: 'low' };
                }

                const response = await fetch('https://api.openai.com/v1/responses', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });

                // Measure TTFB
                const reader = response.body.getReader();
                const firstChunk = await reader.read();
                ttfb = performance.now() - startTime;
                const decoder = new TextDecoder();
                let responseText = decoder.decode(firstChunk.value || new Uint8Array(), { stream: true });

                while (!firstChunk.done) {
                    const nextChunk = await reader.read();
                    if (nextChunk.done) break;
                    responseText += decoder.decode(nextChunk.value, { stream: true });
                }

                // Handle non-OK responses
                if (!response.ok) {
                    const errorData = JSON.parse(responseText);
                    throw new Error(errorData.error.message || 'API request failed.');
                }

                const data = JSON.parse(responseText);
                console.log(`API response for ${model}:`, data);

                endTime = performance.now();

                // Extract text robustly from Responses payloads
                const extractText = (d) => {
                    if (!d || typeof d !== 'object') return '';
                    // 1) Preferred helper
                    if (typeof d.output_text === 'string' && d.output_text.trim()) return d.output_text;
                    // 2) Some SDKs expose `output` as a string
                    if (typeof d.output === 'string' && d.output.trim()) return d.output;
                    // 3) Official shape: array of items with content array
                    if (Array.isArray(d.output)) {
                        const parts = [];
                        for (const item of d.output) {
                            const content = item && item.content;
                            if (Array.isArray(content)) {
                                for (const c of content) {
                                    // Common fields
                                    if (c && typeof c.text === 'string' && c.text) parts.push(c.text);
                                    else if (c && typeof c.output_text === 'string' && c.output_text) parts.push(c.output_text);
                                    // Some responses may nest text under `summary_text`
                                    else if (c && typeof c.summary_text === 'string' && c.summary_text) parts.push(c.summary_text);
                                }
                            } else if (typeof content === 'string' && content.trim()) {
                                parts.push(content);
                            }
                        }
                        if (parts.join('').trim()) return parts.join('\n');
                    }
                    // 4) Rare: chat-like fallback
                    if (Array.isArray(d.choices) && d.choices[0] && d.choices[0].message && typeof d.choices[0].message.content === 'string') {
                        return d.choices[0].message.content;
                    }
                    return '';
                };

                const output = extractText(data);
                const explanation = (output || '').trim() || 'No explanation generated.';

                const { prompt_tokens, completion_tokens, total_tokens } = data.usage || {};
                const totalDuration = endTime - startTime;
                const tokensPerSecond = total_tokens ? total_tokens / (totalDuration / 1000) : 0;

                // Capture status/incomplete reason if present
                const status = data.status || 'unknown';
                const incompleteReason = data.incomplete_details && data.incomplete_details.reason ? data.incomplete_details.reason : null;
                const stats = `Status: ${status}${incompleteReason ? ` (${incompleteReason})` : ''} | TTFB: ${ttfb.toFixed(2)} ms | Total Duration: ${totalDuration.toFixed(2)} ms | Prompt Tokens: ${prompt_tokens ?? 'n/a'} | Completion Tokens: ${completion_tokens ?? 'n/a'} | Total Tokens: ${total_tokens ?? 'n/a'} | Tokens/Second: ${tokensPerSecond.toFixed(2)}`;

                console.log(`Stats for ${model}: ${stats}`);

                return { model, explanation, stats };
            };

            return (
                <div>
                    <h1>Sentence Explainer</h1>
                    <p>
                        This tool allows you to input a sentence in your target language and receive a detailed breakdown to aid in your language learning.<br />
                        First, provide your OpenAI API key, either through the text input field or URL parameter (it will also be stored in the browser local storage for convenience).<br />
                        Enter the sentence you want to understand and click "Explain Sentence". The tool will send a prompt to the selected GPT-5 models using OpenAI's Responses API to generate a detailed breakdown.<br />
                        The returned explanation is displayed below.
                    </p>
                    {/* â–¶/â–¼ System Prompt toggle */}
                    <div
                        style={{ cursor: 'pointer', color: 'blue' }}
                        onClick={() => setShowSystemPrompt(!showSystemPrompt)}
                    >{showSystemPrompt ? 'â–¼' : 'â–¶'} System Prompt</div>
                    {showSystemPrompt && (
                        <textarea
                            value={systemPromptText}
                            onChange={(e) => setSystemPromptText(e.target.value)}
                            style={{ marginTop: '10px', height: '200px' }}
                        />
                    )}

                    <form onSubmit={handleSubmit}>
                        <label>
                            OpenAI API Key:
                            <div style={{ position: 'relative' }}>
                                <input
                                    type={showApiKey ? 'text' : 'password'}
                                    value={apiKey}
                                    onChange={handleApiKeyChange}
                                    placeholder="Enter your API key"
                                    required
                                />
                                <button
                                    type="button"
                                    onClick={toggleApiKeyVisibility}
                                    className="toggle-button"
                                >
                                    {showApiKey ? 'Hide' : 'Show'}
                                </button>
                            </div>
                        </label>
                        <br />
                        <label>
                            Max output tokens:
                            <input
                                type="number"
                                min={256}
                                max={16384}
                                step={256}
                                value={maxOutputTokens}
                                onChange={(e) => setMaxOutputTokens(e.target.value)}
                                style={{ width: '100%' }}
                            />
                        </label>
                        <br />
                        {/* Models selection */}
                        <div style={{ margin: '10px 0' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px', flexWrap: 'wrap' }}>
                                <label style={{ marginRight: '8px' }}>Models:</label>
                                {modelsLoading && <span>(loading modelsâ€¦)</span>}
                                {modelsError && <span className="error">Failed to fetch models: {modelsError}</span>}
                            </div>
                            <div style={{ display: 'flex', gap: '10px', alignItems: 'start', flexWrap: 'wrap', marginTop: '6px' }}>
                                <div style={{ flex: '1 1 320px' }}>
                                    <input
                                        type="text"
                                        placeholder="Filter models (e.g. gpt-5)"
                                        value={modelFilter}
                                        onChange={(e) => setModelFilter(e.target.value)}
                                        style={{ width: '100%', marginBottom: '6px' }}
                                    />
                                    <select
                                        multiple
                                        size={8}
                                        value={models}
                                        onChange={handleModelSelect}
                                        style={{ width: '100%', minWidth: '320px' }}
                                    >
                                        {availableModels
                                            .filter(m => m.toLowerCase().includes(modelFilter.toLowerCase()))
                                            .map(id => (
                                                <option key={id} value={id}>{id}</option>
                                            ))}
                                    </select>
                                    <div style={{ display: 'flex', gap: '8px', marginTop: '6px' }}>
                                        <button type="button" onClick={() => { setModelFilter('gpt-5'); selectFiltered(); }}>Select gpt-5</button>
                                        <button type="button" onClick={selectFiltered}>Select filtered</button>
                                        <button type="button" onClick={clearSelection}>Clear</button>
                                    </div>
                                </div>
                                <div style={{ flex: '1 1 280px' }}>
                                    <label>
                                        Custom models (CSV):
                                        <input
                                            type="text"
                                            value={modelsText}
                                            onChange={handleModelsChange}
                                            placeholder="gpt-5, gpt-5-mini"
                                            style={{ width: '100%' }}
                                        />
                                    </label>
                                </div>
                            </div>
                        </div>
                        <br />
                        <label>
                            Enter Sentence:
                            <textarea
                                value={sentence}
                                onChange={(e) => setSentence(e.target.value)}
                                placeholder="Paste your sentence here..."
                                required
                            ></textarea>
                        </label>
                        <br />
                        <button type="submit" disabled={loading}>
                            {loading ? 'Processing...' : 'Explain Sentence'}
                        </button>
                    </form>
                    {error && <div className="error">Error: {error}</div>}

                    {/* Results Display */}
                    <div className="results-container">
                        {models.map((model) => (
                            <div key={model} className="model-column">
                                <h2>{model}</h2>
                                {results[model] && results[model].explanation && (
                                    <div className="explanation">
                                        <div
                                            className="html-output"
                                            dangerouslySetInnerHTML={{
                                                __html: sanitizeHTML(stripCodeFences(results[model].explanation))
                                            }}
                                        />
                                        <button className="copy-button" onClick={() => copyToClipboard(results[model].explanation)}>
                                            Copy
                                        </button>
                                    </div>
                                )}
                                {results[model] && (
                                    <div className="stats">
                                        <p>{results[model].stats}</p>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(
            <StrictMode>
                <SentenceExplainer />
            </StrictMode>
        );
    </script>
</body>
</html>

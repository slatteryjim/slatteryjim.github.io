<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sentence Explainer with Gemini</title>
    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Optional: Include a CSS library or custom styles here -->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #fafafa;
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            box-sizing: border-box;
            resize: vertical;
        }
        input[type="text"], input[type="password"] {
            padding: 8px;
            margin-top: 10px;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            margin-top: 10px;
            cursor: pointer;
        }
        .explanation {
            background-color: #f0f0f0;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            position: relative; /* For positioning the copy button */
        }
        .explanation h3 {
            margin-top: 0;
        }
        .error {
            color: red;
            margin-top: 10px;
        }
        .toggle-button {
            margin-left: 10px;
            padding: 5px 10px;
            font-size: 0.9em;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .stats {
            font-size: 0.8em;
            margin-top: 10px;
            color: #666;
        }
        .results-container {
            display: flex;
            gap: 20px; /* Spacing between columns */
        }
        .model-column {
            flex: 1; /* Each column takes equal width */
        }
        .copy-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            font-size: 0.8em;
            cursor: pointer;
        }
        /* HTML output styling */
        .html-output h3 { margin: 0.6em 0 0.3em; }
        .html-output h4 { margin: 0.8em 0 0.4em; }
        .html-output ul { margin: 0.25em 0 0.75em 1.25em; }
        .html-output li { margin: 0.2em 0; }
        .html-output ruby { ruby-position: over; font-size: 1.05em; }
        .html-output rt { font-size: 0.6em; color: #666; }
        .html-output .pos { color: #555; font-weight: 600; }
        .html-output .translation { margin: 0.5em 0 1em; }
        .html-output .full-translation blockquote { margin: 0.5em 0; padding-left: 1em; border-left: 3px solid #ddd; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script id="defaultSystemPrompt" type="text/plain">
You are an expert bilingual teaching assistant specializing in Chinese. Your primary goal is to create "Chinese-first, maximum-value" sentence breakdowns for language learners, formatted in clean HTML with ruby annotations for pinyin.

Your task is to take a single Chinese sentence and break it down following the precise format and principles outlined below. Pack the most helpful information into the smallest space, encouraging the learner to stay in Chinese as long as possible.

### Guiding Principles
1.  **Chinese First:** Always present Chinese content before its English equivalent.
2.  **Chunking:** Analyze meaningful phrases (e.g., æˆè¯­, æ­é…) first, then break down their component words.
3.  **Efficiency:** Provide only essential metadata: pinyin, part-of-speech, a concise Chinese gloss, and a concise English gloss.
4.  **Formatting:** Pinyin and all English text (glosses, translations) **must be italicized** using `<em>` tags.

### Strict HTML Formatting Rules

1.  **Clause Headings with Ruby Pinyin:**
    *   Begin each clause with an `<h3>` tag.
    *   The format must be: `<h3><number>&emsp;<segmented Chinese clause with ruby pinyin></h3>`
    *   **Crucially, each space-separated Chinese word/phrase in the clause must be wrapped in `<ruby>` tags, with the pinyin in an `<rt>` tag.** This places the pinyin directly above the characters.
    *   Example: `<h3>1&emsp;<ruby><rb>ä¸ºäº†</rb><rt>wÃ¨iÂ·le</rt></ruby> <ruby><rb>é¡¾å…¨é¢å­</rb><rt>gÃ¹quÃ¡n miÃ nÂ·zi</rt></ruby>ï¼Œ</h3>`

2.  **Vocabulary/Phrase List:**
    *   Use a `<ul>` for the list of vocabulary and phrases.
    *   Each item must be in a `<li>` tag.
    *   The format MUST be: `<strong>Word/Phrase</strong> <em>pinyin</em> <span class="pos">ã€POSã€‘</span> Chinese gloss/synonym â€” <em>English gloss</em>`
    *   **Word/Phrase:** Must be wrapped in `<strong>` tags.
    *   **Pinyin & English Gloss:** Must be wrapped in `<em>` tags. Use a centered dot for neutral tones (e.g., *wÃ¨iÂ·le*).
    *   **ã€POSã€‘:** Wrap the part-of-speech tag in `<span class="pos">`. Use single characters (å, åŠ¨, å½¢, å‰¯, ä»‹, è¿, é‡) or descriptive tags (æ­é…, ç»“æ„, æˆè¯­) as appropriate.

3.  **Clause Micro-Translation:**
    *   End each clause section with a paragraph tag: `<p class="translation">`.
    *   The format MUST be: `<p class="translation">â‡¢ <strong><em>â€œEnglish micro-translationâ€</em></strong></p>`

4.  **Full Sentence Translation:**
    *   At the very end, provide a full translation block within a `<div>` with the class `full-translation`.
    *   The header should be a `<h4>`.
    *   The original sentence and its translation should be inside a `<blockquote>`.
    *   The final English translation must be italicized with `<em>`.
    *   The structure MUST be:
        ```html
        <div class="full-translation">
          <h4>ğŸ“œ ä¸€å¥è¯æ€»è¯‘ Full-sentence translation</h4>
          <blockquote>
            <p class="chinese-sentence">[Original Chinese sentence]</p>
            <p><em>[Full English translation]</em></p>
          </blockquote>
        </div>
        ```

### Gold-Standard HTML Example (Follow this PRECISELY)

**Input Sentence:** ä¸ºäº†é¡¾å…¨é¢å­ï¼Œä»–è£…å‡ºä¸€å‰¯éšéšä¾¿ä¾¿çš„æ ·å­ï¼Œå¥½è®©ä»–çš„ä¼™è®¡ä»¥ä¸ºä»–æ˜¯ä¸ºäº†å¥½ç©å­˜å¿ƒæ•´å¤©æˆ´ç€ä»–é‚£é¡¶å¸½å­çš„ï¼Œå°±åƒç”µå½±é‡Œçš„åŒªå¾’é‚£æ ·ã€‚

**Required HTML Output:**

```html
<h3>1&emsp;<ruby><rb>ä¸ºäº†</rb><rt>wÃ¨iÂ·le</rt></ruby> <ruby><rb>é¡¾å…¨é¢å­</rb><rt>gÃ¹quÃ¡n miÃ nÂ·zi</rt></ruby>ï¼Œ</h3>
<ul>
  <li><strong>ä¸ºäº†</strong> <em>wÃ¨iÂ·le</em> <span class="pos">ã€ä»‹ã€‘</span> ä¸ºäº†â€¦çš„ç›®çš„ â€” <em>in order to; for the sake of</em></li>
  <li><strong>é¡¾å…¨é¢å­</strong> <em>gÃ¹quÃ¡n miÃ nÂ·zi</em> <span class="pos">ã€æ­é…ã€‘</span> ä¿å…¨é¢å­ â€” <em>to save face</em>
    <ul>
      <li><strong>é¡¾å…¨</strong> <em>gÃ¹quÃ¡n</em> <span class="pos">ã€åŠ¨ã€‘</span> ä¿å…¨ã€ç…§é¡¾ â€” <em>to preserve</em></li>
      <li><strong>é¢å­</strong> <em>miÃ nÂ·zi</em> <span class="pos">ã€åã€‘</span> ä½“é¢ã€è„¸é¢ â€” <em>face; reputation</em></li>
    </ul>
  </li>
</ul>
<p class="translation">â‡¢ <strong><em>â€œIn order to save face,â€</em></strong></p>

<h3>2&emsp;<ruby><rb>ä»–</rb><rt>tÄ</rt></ruby> <ruby><rb>è£…å‡º</rb><rt>zhuÄngchÅ«</rt></ruby> <ruby><rb>ä¸€å‰¯</rb><rt>yÄ« fÃ¹</rt></ruby> <ruby><rb>éšéšä¾¿ä¾¿</rb><rt>suÃ­suÃ­-biÃ nbian</rt></ruby> <ruby><rb>çš„</rb><rt>de</rt></ruby> <ruby><rb>æ ·å­</rb><rt>yÃ ngÂ·zi</rt></ruby>ï¼Œ</h3>
<ul>
  <li><strong>è£…å‡º</strong> <em>zhuÄngchÅ«</em> <span class="pos">ã€åŠ¨ã€‘</span> å‡è£…è¡¨ç° â€” <em>to feign, put on</em></li>
  <li><strong>ä¸€å‰¯</strong> <em>yÄ« fÃ¹</em> <span class="pos">ã€é‡ã€‘</span> ï¼ˆè¡¨ç¥æ€çš„é‡è¯ï¼‰ â€” <em>classifier for looks</em></li>
  <li><strong>éšéšä¾¿ä¾¿</strong> <em>suÃ­suÃ­-biÃ nbian</em> <span class="pos">ã€å½¢ã€‘</span> ä¸æ‹˜å°èŠ‚ã€å¾ˆéšæ„ â€” <em>casual; nonchalant</em></li>
  <li><strong>æ ·å­</strong> <em>yÃ ngÂ·zi</em> <span class="pos">ã€åã€‘</span> å¤–è¡¨ã€ç¥æ€ â€” <em>appearance; manner</em></li>
</ul>
<p class="translation">â‡¢ <strong><em>â€œhe put on a casual, nonchalant air,â€</em></strong></p>

<h3>3&emsp;<ruby><rb>å¥½è®©</rb><rt>hÇo-rÃ ng</rt></ruby> <ruby><rb>ä»–</rb><rt>tÄ</rt></ruby> <ruby><rb>çš„</rb><rt>de</rt></ruby> <ruby><rb>ä¼™è®¡</rb><rt>huÇ’Â·ji</rt></ruby> <ruby><rb>ä»¥ä¸º</rb><rt>yÇwÃ©i</rt></ruby></h3>
<ul>
  <li><strong>å¥½è®©</strong> <em>hÇo-rÃ ng</em> <span class="pos">ã€è¿ã€‘</span> ä»¥ä¾¿ã€ä¸ºäº†ä½¿ â€” <em>so that</em></li>
  <li><strong>ä¼™è®¡</strong> <em>huÇ’Â·ji</em> <span class="pos">ã€åã€‘</span> åŒä¼´ã€æœ‹å‹ï¼ˆå£è¯­ã€ç¨æ—§ï¼‰ â€” <em>buddy; mate</em></li>
  <li><strong>ä»¥ä¸º</strong> <em>yÇwÃ©i</em> <span class="pos">ã€åŠ¨ã€‘</span> è®¤ä¸ºã€è¯¯ä»¥ä¸º â€” <em>to assume (often wrongly)</em></li>
</ul>
<p class="translation">â‡¢ <strong><em>â€œso that his buddies would assumeâ€</em></strong></p>

<h3>4&emsp;<ruby><rb>ä»–</rb><rt>tÄ</rt></ruby> <ruby><rb>æ˜¯</rb><rt>shÃ¬</rt></ruby> <ruby><rb>ä¸ºäº†å¥½ç©</rb><rt>wÃ¨iÂ·le hÇowÃ¡n</rt></ruby> <ruby><rb>å­˜å¿ƒ</rb><rt>cÃºnxÄ«n</rt></ruby> <ruby><rb>æ•´å¤©</rb><rt>zhÄ›ngtiÄn</rt></ruby> <ruby><rb>æˆ´ç€</rb><rt>dÃ iÂ·zhe</rt></ruby> <ruby><rb>ä»–</rb><rt>tÄ</rt></ruby> <ruby><rb>é‚£</rb><rt>nÃ </rt></ruby> <ruby><rb>é¡¶</rb><rt>dÇng</rt></ruby> <ruby><rb>å¸½å­</rb><rt>mÃ oÂ·zi</rt></ruby> <ruby><rb>çš„</rb><rt>de</rt></ruby>ï¼Œ</h3>
<ul>
  <li><strong>ä¸ºäº†å¥½ç©</strong> <em>wÃ¨iÂ·le hÇowÃ¡n</em> <span class="pos">ã€æ­é…ã€‘</span> ä¸ºäº†æœ‰è¶£ â€” <em>for fun</em></li>
  <li><strong>å­˜å¿ƒ</strong> <em>cÃºnxÄ«n</em> <span class="pos">ã€å‰¯ã€‘</span> æ•…æ„ã€æœ‰æ„ â€” <em>deliberately</em></li>
  <li><strong>æ•´å¤©</strong> <em>zhÄ›ngtiÄn</em> <span class="pos">ã€å‰¯ã€‘</span> ä¸€å¤©åˆ°æ™š â€” <em>all day</em></li>
  <li><strong>æˆ´ç€</strong> <em>dÃ iÂ·zhe</em> <span class="pos">ã€åŠ¨+ç€ã€‘</span> å¤´ä¸Šæˆ´ç€ï¼ˆæŒç»­ï¼‰ â€” <em>wearing (durative)</em></li>
  <li><strong>é¡¶</strong> <em>dÇng</em> <span class="pos">ã€é‡ã€‘</span> å¸½å­çš„é‡è¯ â€” <em>MW for hats</em></li>
  <li><strong>å¸½å­</strong> <em>mÃ oÂ·zi</em> <span class="pos">ã€åã€‘</span> å¸½å­ â€” <em>hat</em></li>
</ul>
<p class="translation">â‡¢ <strong><em>â€œhe kept that hat on all day purely for fun,â€</em></strong></p>

<h3>5&emsp;<ruby><rb>å°±åƒ</rb><rt>jiÃ¹xiÃ ng</rt></ruby> <ruby><rb>ç”µå½±é‡Œçš„</rb><rt>diÃ nyÇng lÇ de</rt></ruby> <ruby><rb>åŒªå¾’</rb><rt>fÄ›itÃº</rt></ruby> <ruby><rb>é‚£æ ·</rb><rt>nÃ yÃ ng</rt></ruby>ã€‚</h3>
<ul>
  <li><strong>å°±åƒ â€¦ é‚£æ ·</strong> <em>jiÃ¹xiÃ ng â€¦ nÃ yÃ ng</em> <span class="pos">ã€ç»“æ„ã€‘</span> å¦‚åŒâ€¦ â€” <em>just like â€¦</em></li>
  <li><strong>ç”µå½±é‡Œçš„</strong> <em>diÃ nyÇng lÇ de</em> <span class="pos">ã€ç»“æ„ã€‘</span> åœ¨ç”µå½±ä¸­çš„ â€” <em>in the movies</em></li>
  <li><strong>åŒªå¾’</strong> <em>fÄ›itÃº</em> <span class="pos">ã€åã€‘</span> åœŸåŒªã€å¼ºç›— â€” <em>bandit (old-style)</em></li>
</ul>
<p class="translation">â‡¢ <strong><em>â€œjust like the bandits in the movies.â€</em></strong></p>

<div class="full-translation">
  <h4>ğŸ“œ ä¸€å¥è¯æ€»è¯‘ Full-sentence translation</h4>
  <blockquote>
    <p class="chinese-sentence">ä¸ºäº†é¡¾å…¨é¢å­ï¼Œä»–è£…å‡ºä¸€å‰¯éšéšä¾¿ä¾¿çš„æ ·å­ï¼Œå¥½è®©ä»–çš„ä¼™è®¡ä»¥ä¸ºä»–æ˜¯ä¸ºäº†å¥½ç©å­˜å¿ƒæ•´å¤©æˆ´ç€ä»–é‚£é¡¶å¸½å­çš„ï¼Œå°±åƒç”µå½±é‡Œçš„åŒªå¾’é‚£æ ·ã€‚</p>
    <p><em>In order to save face, he affected a laid-back look so his buddies would think he wore that hat all day just for funâ€”like the bandits in the movies.</em></p>
  </blockquote>
</div>
```
    </script>

    <script type="text/babel" data-type="module" data-presets="env,react,typescript">
        const { useState, useEffect, StrictMode } = React;

        const models = [
            "gemini-2.5-pro",
            "gemini-2.5-flash-thinking",
            "gemini-2.5-flash-no-thinking",
            "gemini-2.5-flash-lite"
        ];

        // Strip common code fences like ```html ... ```
        const stripCodeFences = (s) => {
            if (!s) return '';
            let out = s.trim();
            out = out.replace(/^```(?:html)?\s*/i, '');
            out = out.replace(/\s*```$/i, '');
            return out.trim();
        };

        // Very light sanitizer to prevent script injection from model output
        const sanitizeHTML = (html) => {
            const doc = new DOMParser().parseFromString(html || '', 'text/html');
            doc.querySelectorAll('script, style, iframe, object, embed, link').forEach(el => el.remove());
            doc.querySelectorAll('*').forEach(el => {
                [...el.attributes].forEach(attr => {
                    const name = attr.name.toLowerCase();
                    const val = (attr.value || '').trim().toLowerCase();
                    if (name.startsWith('on')) el.removeAttribute(attr.name);
                    if ((name === 'href' || name === 'src') && val.startsWith('javascript:')) el.removeAttribute(attr.name);
                });
            });
            return doc.body.innerHTML;
        };

        const promptEl = document.getElementById('defaultSystemPrompt');
        const defaultSystemPrompt = (promptEl ? promptEl.textContent : '').trim();

        const SentenceExplainer = () => {
            // State variables
            const [sentence, setSentence] = useState('å›½å¤®ä¼å¦‚æ­¤çƒ­åˆ‡æ‹¥æŠ±å¤§æ¨¡å‹æˆ–ä¸ä¸€é“æ–°æ”¿æœ‰å…³ã€‚');
            const [apiKey, setApiKey] = useState('');
            const [results, setResults] = useState({}); // Store results for all models
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            const [showApiKey, setShowApiKey] = useState(false);
            const [isReady, setIsReady] = useState(false);
            const [systemPromptText, setSystemPromptText] = useState(defaultSystemPrompt);
            const [showSystemPrompt, setShowSystemPrompt] = useState(false);

            // Load API key and sentence, then set isReady
            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const sentenceFromUrl = urlParams.get('sentence');
                const apiKeyFromUrl = urlParams.get('apiKey');

                // Prioritize URL parameters over localStorage
                if (sentenceFromUrl) {
                    setSentence(decodeURIComponent(sentenceFromUrl));
                }

                const handleApiKey = (key) => {
                    if (key) {
                        setApiKey(key);
                        localStorage.setItem('gemini_api_key', key);
                    }
                    setIsReady(true); // Everything is ready now
                };

                if (apiKeyFromUrl) {
                    handleApiKey(decodeURIComponent(apiKeyFromUrl));
                } else {
                    const storedApiKey = localStorage.getItem('gemini_api_key');
                    handleApiKey(storedApiKey);
                }
            }, []);

            // Trigger handleSubmit when isReady changes and sentence is available
            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const sentenceFromUrl = urlParams.get('sentence');
                if (isReady && sentenceFromUrl) {
                    handleSubmit(null, decodeURIComponent(sentenceFromUrl));
                }
            }, [isReady]);

            // Function to handle API key changes
            const handleApiKeyChange = (e) => {
                const value = e.target.value;
                setApiKey(value);
                localStorage.setItem('gemini_api_key', value);
            };

            // Function to toggle API key visibility
            const toggleApiKeyVisibility = () => {
                setShowApiKey(!showApiKey);
            };

            // Function to copy text to clipboard
            const copyToClipboard = (text) => {
                navigator.clipboard.writeText(text).then(() => {
                    // Optional: Show a success message or change the button text briefly
                    console.log('Text copied to clipboard');
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                });
            };

            // Function to handle form submission or direct call from URL param
            const handleSubmit = async (e, sentenceFromUrl = null) => {
                if (e) e.preventDefault();
                const currentSentence = sentenceFromUrl || sentence;
                setError(null);
                setResults({}); // Clear previous results
                setLoading(true);

                if (!apiKey) {
                    setError('Please provide your Gemini API key.');
                    setLoading(false);
                    return;
                }

                if (!currentSentence.trim()) {
                    setError('Please enter a sentence to process.');
                    setLoading(false);
                    return;
                }

                models.forEach(async (model) => {
                    try {
                        const result = await queryGemini(model, currentSentence);
                        // Update results for the specific model as it completes
                        setResults((prevResults) => ({
                            ...prevResults,
                            [model]: result,
                        }));
                    } catch (err) {
                        console.error(`Error with model ${model}:`, err);
                        // Update results with an error for the specific model
                        setResults((prevResults) => ({
                            ...prevResults,
                            [model]: {
                                model: model,
                                explanation: null,
                                stats: `Error: ${err.message || 'An unexpected error occurred.'}`,
                            },
                        }));
                    }
                });

                setLoading(false);
            };

            // Function to query a single Gemini model
            const queryGemini = async (model, currentSentence) => {
                const startTime = performance.now();
                let endTime;
                let ttfb;

                // Determine the actual model ID for the API endpoint
                const modelId = model.replace(/-no-thinking|-thinking/, '');

                // Prepare the system prompt from state
                const systemPrompt = systemPromptText;

                // Make the API call
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelId}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                                role: "user",
                                parts: [{ text: currentSentence }]
                            }
                        ],
                        systemInstruction: {
                            role: "system",
                            parts: [{text: systemPrompt}]
                        },
                        // Add thinking budget config for the no-thinking variant
                        ...(model.endsWith('-no-thinking') && {
                            generationConfig: {
                                thinkingConfig: {
                                    thinkingBudget: 0
                                }
                            }
                        })
                    })
                });

                // Measure TTFB
                const reader = response.body.getReader();
                const firstChunk = await reader.read();
                ttfb = performance.now() - startTime;
                const decoder = new TextDecoder();
                let responseText = decoder.decode(firstChunk.value || new Uint8Array(), { stream: true });

                while (!firstChunk.done) {
                    const nextChunk = await reader.read();
                    if (nextChunk.done) break;
                    responseText += decoder.decode(nextChunk.value, { stream: true });
                }

                // Handle non-OK responses
                if (!response.ok) {
                    const errorData = JSON.parse(responseText);
                    throw new Error(errorData.error.message || 'API request failed.');
                }

                const data = JSON.parse(responseText);
                console.log(`API response for ${model}:`, data);

                endTime = performance.now();

                const candidates = data.candidates || [];
                const parts = candidates[0]?.content?.parts || [];
                const explanation = parts.map(p => p.text || '').join('') || 'No explanation generated.';

                const { promptTokenCount, candidatesTokenCount, totalTokenCount } = data.usageMetadata;
                const totalDuration = endTime - startTime;
                const tokensPerSecond = totalTokenCount / (totalDuration / 1000);

                const stats = `TTFB: ${ttfb.toFixed(2)} ms | Total Duration: ${totalDuration.toFixed(2)} ms | Prompt Tokens: ${promptTokenCount} | Candidates Tokens: ${candidatesTokenCount} | Total Tokens: ${totalTokenCount} | Tokens/Second: ${tokensPerSecond.toFixed(2)}`;

                console.log(`Stats for ${model}: ${stats}`);

                return { model, explanation, stats };
            };

            return (
                <div>
                    <h1>Sentence Explainer</h1>
                    <p>
                        This tool allows you to input a sentence in your target language and receive a detailed breakdown to aid in your language learning.<br />
                        First, provide your Gemini API key, either through the text input field or URL parameter (it will also be stored in the browser local storage for convenience).<br />
                        Enter the sentence you want to understand and click "Explain Sentence". The tool will send a prompt to Gemini API to generate a detailed breakdown.<br />
                        The returned explanation is displayed below.
                    </p>
                    {/* â–¶/â–¼ System Prompt toggle */}
                    <div
                        style={{ cursor: 'pointer', color: 'blue' }}
                        onClick={() => setShowSystemPrompt(!showSystemPrompt)}
                    >{showSystemPrompt ? 'â–¼' : 'â–¶'} System Prompt</div>
                    {showSystemPrompt && (
                        <textarea
                            value={systemPromptText}
                            onChange={(e) => setSystemPromptText(e.target.value)}
                            style={{ marginTop: '10px', height: '200px' }}
                        />
                    )}

                    <form onSubmit={handleSubmit}>
                        <label>
                            Gemini API Key:
                            <div style={{ position: 'relative' }}>
                                <input
                                    type={showApiKey ? 'text' : 'password'}
                                    value={apiKey}
                                    onChange={handleApiKeyChange}
                                    placeholder="Enter your API key"
                                    required
                                />
                                <button
                                    type="button"
                                    onClick={toggleApiKeyVisibility}
                                    className="toggle-button"
                                >
                                    {showApiKey ? 'Hide' : 'Show'}
                                </button>
                            </div>
                        </label>
                        <br />
                        <label>
                            Enter Sentence:
                            <textarea
                                value={sentence}
                                onChange={(e) => setSentence(e.target.value)}
                                placeholder="Paste your sentence here..."
                                required
                            ></textarea>
                        </label>
                        <br />
                        <button type="submit" disabled={loading}>
                            {loading ? 'Processing...' : 'Explain Sentence'}
                        </button>
                    </form>
                    {error && <div className="error">Error: {error}</div>}

                    {/* Results Display */}
                    <div className="results-container">
                        {models.map((model) => (
                            <div key={model} className="model-column">
                                <h2>{model}</h2>
                                {results[model] && results[model].explanation && (
                                    <div className="explanation">
                                        <div
                                            className="html-output"
                                            dangerouslySetInnerHTML={{
                                                __html: sanitizeHTML(stripCodeFences(results[model].explanation))
                                            }}
                                        />
                                        <button className="copy-button" onClick={() => copyToClipboard(results[model].explanation)}>
                                            Copy
                                        </button>
                                    </div>
                                )}
                                {results[model] && (
                                    <div className="stats">
                                        <p>{results[model].stats}</p>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(
            <StrictMode>
                <SentenceExplainer />
            </StrictMode>
        );
    </script>
</body>
</html>

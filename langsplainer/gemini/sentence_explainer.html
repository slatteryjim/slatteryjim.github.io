<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sentence Explainer with Gemini</title>
    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Optional: Include a CSS library or custom styles here -->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #fafafa;
        }
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            box-sizing: border-box;
            resize: vertical;
        }
        input[type="text"], input[type="password"] {
            padding: 8px;
            margin-top: 10px;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            margin-top: 10px;
            cursor: pointer;
        }
        .explanation {
            background-color: #f0f0f0;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .explanation h3 {
            margin-top: 0;
        }
        .error {
            color: red;
            margin-top: 10px;
        }
        .toggle-button {
            margin-left: 10px;
            padding: 5px 10px;
            font-size: 0.9em;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .stats {
            font-size: 0.8em;
            margin-top: 10px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="env,react,typescript">
        const { useState, useEffect, StrictMode } = React;

        const models = [
            "gemini-2.0-flash-exp",
            "gemini-1.5-flash-8b",
            "gemini-exp-1206",
        ]

        const SentenceExplainer = () => {
            // State variables
            const [sentence, setSentence] = useState('国央企如此热切拥抱大模型或与一道新政有关。');
            const [apiKey, setApiKey] = useState('');
            const [explanation, setExplanation] = useState(null);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            const [showApiKey, setShowApiKey] = useState(false);
            const [model, setModel] = useState(models[0]);
            const [stats, setStats] = useState(null); // State for storing stats

            // Load API key from localStorage or URL hash on initial render
            useEffect(() => {
                // Attempt to load from localStorage
                const storedApiKey = localStorage.getItem('gemini_api_key');
                if (storedApiKey) {
                    setApiKey(storedApiKey);
                } else {
                    // Fallback to URL hash
                    const hash = window.location.hash.substring(1);
                    if (hash.startsWith('apiKey=')) {
                        const key = decodeURIComponent(hash.split('=')[1]);
                        setApiKey(key);
                        localStorage.setItem('gemini_api_key', key);
                    }
                }
            }, []);

            // Function to handle API key changes
            const handleApiKeyChange = (e) => {
                const value = e.target.value;
                setApiKey(value);
                localStorage.setItem('gemini_api_key', value);
            };

            // Function to toggle API key visibility
            const toggleApiKeyVisibility = () => {
                setShowApiKey(!showApiKey);
            };

            // Function to handle model selection changes
            const handleModelChange = (e) => {
                setModel(e.target.value);
            };

            // Function to handle form submission
            const handleSubmit = async (e) => {
                e.preventDefault();
                setError(null);
                setStats(null); // Reset stats on new submission

                if (!apiKey) {
                    setError('Please provide your Gemini API key.');
                    return;
                }

                if (!sentence.trim()) {
                    setError('Please enter a sentence to process.');
                    return;
                }

                setLoading(true);

                // --- Performance and Stats Measurement Start ---
                const startTime = performance.now();
                let endTime;
                let ttfb;

                try {
                    console.log('Input sentence:', sentence);

                    // Prepare the prompt for Gemini
                    const systemPrompt = `I'd like you to be a language sentence explainer.

The user was reading some text, and they came across a sentence that they didn't understand.
Maybe they didn't understand one word or phrase, or maybe they knew each word, but didn't understand what the sentence as a whole meant.

They will provide a snippet for context, and then the particular sentence to focus on.

Pretend you are a language mentor and fluent speaker of their target language, and you should only reply in that language.
You are very encouraging of them to succeed in their studies.
When a user provides a sentence, the GPT will offer the following types of explanations, always responding in the target language of the sentence:

- **Segmented Sentence Breakdown**: A breakdown of the sentence where each word or important phrase is separated by a newline. After each word/phrase, include in parentheses the accurate pronunciation (e.g., pinyin) and an explanatory alternative in the target language. If the target language gloss is particularly difficult, an English gloss may be provided as well.

There will be no additional commentary or chitchat.

Here's an example response:
"""
- 国央企 (guó yāng qǐ) [国家和中央的企业] - state-owned enterprises
- 如此 (rúcǐ) [这么地] - so
- 热切 (rèqiè) [非常热情地] - eagerly
- 拥抱 (yōngbào) [接受] - embrace
- 大模型 (dà móxíng) [大型的AI模型] - large models
- 或 (huò) [可能] - perhaps
- 与 (yǔ) [和] - with
- 一道 (yídào) [一个] - a
- 新政 (xīnzhèng) [新的政策] - new policy
- 有关 (yǒuguān) [有关系] - related to
"""

And now here is the sentence provided by the user:
`;
                    const userPrompt = sentence;
                    const prompt = systemPrompt + userPrompt;
                    const inputTokenCount = prompt.length; // Rough estimate of input tokens

                    // Make the API call to Gemini
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                role: "user",
                                parts: [{ text: prompt }]
                            }]
                        })
                    });

                    // Measure Time To First Byte (TTFB)
                    const reader = response.body.getReader();
                    const firstChunk = await reader.read();
                    ttfb = performance.now() - startTime;
                    const decoder = new TextDecoder();
                    let responseText = decoder.decode(firstChunk.value || new Uint8Array, { stream: true });

                    while (!firstChunk.done) {
                        const nextChunk = await reader.read();
                        if (nextChunk.done) break;
                        responseText += decoder.decode(nextChunk.value, { stream: true });
                    }

                    // Handle non-OK responses
                    if (!response.ok) {
                        const errorData = JSON.parse(responseText); // Parse the error response as JSON
                        throw new Error(errorData.error.message || 'API request failed.');
                    }

                    const data = JSON.parse(responseText); // Parse the whole response as JSON
                    console.log('API response:', data);

                    endTime = performance.now(); // Capture end time after receiving full response

                    if (!data.candidates || data.candidates.length === 0) {
                        throw new Error("No candidates returned in API response.");
                    }
                    const candidate = data.candidates[0];

                    if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
                      throw new Error("No content returned for candidate.");
                    }

                    const explanationText = candidate.content.parts[0].text;
                    setExplanation(explanationText);

                    // Estimate output tokens (Gemini API doesn't provide exact token counts)
                    const outputTokenCount = explanationText.length; // Rough estimate

                    // Calculate stats
                    const totalDuration = endTime - startTime;
                    const tokensPerSecond = (inputTokenCount + outputTokenCount) / (totalDuration / 1000);

                    setStats({
                        ttfb: ttfb.toFixed(2),
                        totalDuration: totalDuration.toFixed(2),
                        inputTokens: inputTokenCount,
                        outputTokens: outputTokenCount,
                        tokensPerSecond: tokensPerSecond.toFixed(2),
                    });

                    // Log stats to console
                    console.log(`Model: ${model}`);
                    console.log(`TTFB: ${ttfb.toFixed(2)} ms`);
                    console.log(`Total Duration: ${totalDuration.toFixed(2)} ms`);
                    console.log(`Input Tokens: ${inputTokenCount}`);
                    console.log(`Output Tokens: ${outputTokenCount}`);
                    console.log(`Tokens/Second: ${tokensPerSecond.toFixed(2)}`);

                } catch (err) {
                    console.error(err);
                    setError(err.message || 'An unexpected error occurred.');
                } finally {
                    setLoading(false);
                }
                // --- Performance and Stats Measurement End ---
            };

            return (
                <div>
                    <h1>Sentence Explainer</h1>
                    <p>
                        This tool allows you to input a sentence in your target language and receive a detailed breakdown to aid in your language learning.<br />
                        First, provide your Gemini API key, either through the text input field or URL hash (it will also be stored in the browser local storage for convenience).<br />
                        Enter the sentence you want to understand and click "Explain Sentence". The tool will send a prompt to Gemini API to generate a detailed breakdown.<br />
                        The returned explanation is displayed below.
                    </p>
                    <form onSubmit={handleSubmit}>
                        <label>
                            Gemini API Key:
                            <div style={{ position: 'relative' }}>
                                <input
                                    type={showApiKey ? 'text' : 'password'}
                                    value={apiKey}
                                    onChange={handleApiKeyChange}
                                    placeholder="Enter your API key"
                                    required
                                />
                                <button
                                    type="button"
                                    onClick={toggleApiKeyVisibility}
                                    className="toggle-button"
                                >
                                    {showApiKey ? 'Hide' : 'Show'}
                                </button>
                            </div>
                        </label>
                        <br />
                        <label>
                            Model:
                            <select value={model} onChange={handleModelChange}>
                                {models.map((model) => (
                                    <option key={model} value={model}>
                                        {model}
                                    </option>
                                ))}
                            </select>
                        </label>
                        <br />
                        <label>
                            Enter Sentence:
                            <textarea
                                value={sentence}
                                onChange={(e) => setSentence(e.target.value)}
                                placeholder="Paste your sentence here..."
                                required
                            ></textarea>
                        </label>
                        <br />
                        <button type="submit" disabled={loading}>
                            {loading ? 'Processing...' : 'Explain Sentence'}
                        </button>
                    </form>
                    {error && <div className="error">Error: {error}</div>}
                    {explanation && (
                        <div>
                            <h2>Explanation:</h2>
                            <div className="explanation">
                                <pre>{explanation}</pre>
                            </div>
                        </div>
                    )}
                    {/* Display Stats */}
                    {stats && (
                        <div className="stats">
                            <p><b>Model:</b> {model}</p>
                            <p><b>TTFB:</b> {stats.ttfb} ms</p>
                            <p><b>Total Duration:</b> {stats.totalDuration} ms</p>
                            <p><b>Input Tokens (estimate):</b> {stats.inputTokens}</p>
                            <p><b>Output Tokens (estimate):</b> {stats.outputTokens}</p>
                            <p><b>Tokens/Second (estimate):</b> {stats.tokensPerSecond}</p>
                        </div>
                    )}
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(
            <StrictMode>
                <SentenceExplainer />
            </StrictMode>
        );
    </script>
</body>
</html>